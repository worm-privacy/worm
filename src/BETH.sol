// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ProofOfBurnVerifier} from "./ProofOfBurnVerifier.sol";
import {SpendVerifier} from "./SpendVerifier.sol";

contract BETH is ERC20 {
    uint256 public constant MINT_CAP = 10 ether;

    ProofOfBurnVerifier public proofOfBurnVerifier;
    SpendVerifier public spendVerifier;
    mapping(uint256 => bool) public nullifiers;
    mapping(uint256 => uint256) public coins; // Map each coin to its root coin
    mapping(uint256 => uint256) public revealed; // Total revealed amount of a root coin

    constructor() ERC20("Burned ETH", "BETH") {
        proofOfBurnVerifier = new ProofOfBurnVerifier();
        spendVerifier = new SpendVerifier();
    }

    /**
     * @notice Mints new BETH tokens by proving ETH was burned to a valid burn address.
     * @dev This function verifies a zkSNARK proof generated by the ProofOfBurn circuit.
     * @param _pA zkSNARK proof element A.
     * @param _pB zkSNARK proof element B.
     * @param _pC zkSNARK proof element C.
     * @param _blockNumber The block number whose state root is used in the proof.
     * @param _nullifier The nullifier derived from Poseidon2(POSEIDON_NULLIFIER_PREFIX, burnKey).
     * @param _remainingCoin The encrypted leftover balance commitment.
     * @param _broadcasterFee Fee paid to the relayer who submits the proof.
     * @param _revealedAmount Amount directly revealed (minted to receiver).
     * @param _revealedAmountReceiver Receiver of the directly revealed BETH.
     * @param _proverFee Fee paid to the prover who generated the zk proof.
     * @param _prover The address of the prover.
     */
    function mintCoin(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256 _blockNumber,
        uint256 _nullifier,
        uint256 _remainingCoin,
        uint256 _broadcasterFee,
        uint256 _revealedAmount,
        address _revealedAmountReceiver,
        uint256 _proverFee,
        address _prover
    ) public {
        uint256 burnExtraCommitment =
            uint256(keccak256(abi.encodePacked(_broadcasterFee, _proverFee, _revealedAmountReceiver))) >> 8;
        uint256 proofExtraCommitment = uint256(keccak256(abi.encodePacked(_prover))) >> 8;
        require(_revealedAmount <= MINT_CAP, "Mint is capped!");
        require(_proverFee + _broadcasterFee <= _revealedAmount, "More fee than revealed!");
        require(!nullifiers[_nullifier], "Nullifier already consumed!");
        require(coins[_remainingCoin] == 0, "Coin already minted!");
        require(blockhash(_blockNumber) != bytes32(0), "Block root unavailable!");
        uint256 commitment =
            uint256(
                    keccak256(
                        abi.encodePacked(
                            blockhash(_blockNumber),
                            _nullifier,
                            _remainingCoin,
                            _revealedAmount,
                            burnExtraCommitment,
                            proofExtraCommitment
                        )
                    )
                ) >> 8;
        require(proofOfBurnVerifier.verifyProof(_pA, _pB, _pC, [commitment]), "Invalid proof!");
        if (_broadcasterFee != 0) {
            _mint(msg.sender, _broadcasterFee);
        }
        if (_proverFee != 0) {
            _mint(_prover, _proverFee);
        }
        _mint(_revealedAmountReceiver, _revealedAmount - _broadcasterFee - _proverFee);
        nullifiers[_nullifier] = true;
        coins[_remainingCoin] = _remainingCoin; // Minted coin is a root coin
        revealed[_remainingCoin] = _revealedAmount;
    }

    /**
     * @notice Reveals part of an existing BETH "coin" using a zero-knowledge proof.
     * @param _pA zkSNARK proof element A.
     * @param _pB zkSNARK proof element B.
     * @param _pC zkSNARK proof element C.
     * @param _coin The encrypted coin being spent.
     * @param _amount The amount being revealed/minted to the receiver.
     * @param _remainingCoin The new encrypted coin for the remaining balance.
     * @param _broadcasterFee Fee paid to the transaction sender.
     * @param _receiver The address receiving the revealed amount.
     */
    function spendCoin(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256 _coin,
        uint256 _amount,
        uint256 _remainingCoin,
        uint256 _broadcasterFee,
        address _receiver
    ) public {
        uint256 rootCoin = coins[_coin];
        require(rootCoin != 0, "Coin does not exist");
        require(coins[_remainingCoin] == 0, "Remaining coin already exists");
        uint256 commitment =
            uint256(
                    keccak256(
                        abi.encodePacked(_coin, _amount, _remainingCoin, _broadcasterFee, uint256(uint160(_receiver)))
                    )
                ) >> 8;
        require(spendVerifier.verifyProof(_pA, _pB, _pC, [commitment]), "Invalid proof!");
        _mint(msg.sender, _broadcasterFee);
        _mint(_receiver, _amount);
        coins[_coin] = 0;
        coins[_remainingCoin] = rootCoin;
        revealed[rootCoin] += _amount + _broadcasterFee;
        require(revealed[rootCoin] <= MINT_CAP, "Mint is capped!");
    }
}
