// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {IRewardPool} from "./Staking.sol";
import {IVerifier} from "./IVerifier.sol";

contract BETH is ERC20, ReentrancyGuard {
    event HookFailure(bytes returnData);

    uint256 public constant MINT_CAP = 10 ether;
    uint256 public constant POOL_SHARE_INV = 200; // 1 / 200 = 0.5%

    address initializer; // The address which has the permission to initialize the rewardPool
    IRewardPool public rewardPool;

    IVerifier public proofOfBurnVerifier;
    IVerifier public spendVerifier;
    mapping(uint256 => bool) public nullifiers;
    mapping(uint256 => uint256) public coins; // Map each coin to its root coin
    mapping(uint256 => uint256) public revealed; // Total revealed amount of a root coin

    constructor(
        IVerifier _proofOfBurnVerifier,
        IVerifier _spendVerifier,
        address _premineAddress,
        uint256 _premineAmount
    ) ERC20("Burned ETH", "BETH") {
        proofOfBurnVerifier = _proofOfBurnVerifier;
        spendVerifier = _spendVerifier;
        initializer = msg.sender;
        if (_premineAddress != address(0)) {
            _mint(_premineAddress, _premineAmount);
        }
    }

    function initRewardPool(IRewardPool _rewardPool) external {
        require(msg.sender == initializer, "Only the initializer can initialize!");
        require(address(rewardPool) == address(0), "Reward pool already set!");
        rewardPool = _rewardPool;
    }

    function mintForRewardPool(uint256 _amount) internal {
        _mint(address(this), _amount);
        _approve(address(this), address(rewardPool), _amount);
        rewardPool.depositReward(_amount);
        _approve(address(this), address(rewardPool), 0);
    }

    /**
     * @notice Handles optional post-mint hooks for BETH recipients
     * @dev Executes arbitrary calldata against a target contract with temporary token approval.
     *      Failure does not revert the main mint; only emits an event.
     * @param _bethOwner The address whose BETH is approved for the hook
     * @param _hookData ABI-encoded (target address, allowance, calldata)
     */
    function handleHook(address _bethOwner, bytes memory _hookData) internal {
        // Hooks are optional
        if (_hookData.length != 0) {
            // Decode the hook parameters
            (address hookAddress, uint256 hookAllowance, bytes memory hookCalldata) =
                abi.decode(_hookData, (address, uint256, bytes));

            // Approve the hook to spend BETH
            _approve(_bethOwner, hookAddress, hookAllowance);

            // Execute the hook
            require(hookAddress.code.length > 0, "Target is not a contract");
            (bool success, bytes memory returnData) = hookAddress.call{value: 0}(hookCalldata);

            // Reset approval to zero for safety
            _approve(_bethOwner, hookAddress, 0);

            // No need to force `success` to be true. Failure should not prevent the burner from receiving their BETH.
            if (!success) {
                emit HookFailure(returnData);
            }
        }
    }

    /**
     * @notice Mints new BETH tokens by proving ETH was burned to a valid burn address.
     * @dev This function verifies a zkSNARK proof generated by the ProofOfBurn circuit.
     * @param _pA zkSNARK proof element A.
     * @param _pB zkSNARK proof element B.
     * @param _pC zkSNARK proof element C.
     * @param _blockNumber The block number whose state root is used in the proof.
     * @param _nullifier The nullifier derived from Poseidon2(POSEIDON_NULLIFIER_PREFIX, burnKey).
     * @param _remainingCoin The encrypted leftover balance commitment.
     * @param _broadcasterFee Fee paid to the relayer who submits the proof.
     * @param _revealedAmount Amount directly revealed (minted to receiver).
     * @param _revealedAmountReceiver Receiver of the directly revealed BETH.
     * @param _proverFee Fee paid to the prover who generated the zk proof.
     * @param _prover The address of the prover.
     * @param _receiverPostMintHook The receiver may sell his BETH for ETH through a hook.
     * @param _broadcasterFeePostMintHook The broadcaster may sell his BETH for ETH through a hook.
     */
    function mintCoin(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256 _blockNumber,
        uint256 _nullifier,
        uint256 _remainingCoin,
        uint256 _broadcasterFee,
        uint256 _revealedAmount,
        address _revealedAmountReceiver,
        uint256 _proverFee,
        address _prover,
        bytes calldata _receiverPostMintHook,
        bytes calldata _broadcasterFeePostMintHook
    ) public nonReentrant {
        require(address(rewardPool) != address(0), "Reward pool not initialized!");

        // Information bound to the burn (shifted right by 8 to fit within field elements).
        // The burn address is computed as: Poseidon4(POSEIDON_BURN_PREFIX, burnKey, revealAmount, burnExtraCommitment)[:20].
        // Once ETH is sent to the burn address, the data in burnExtraCommitment cannot be changed.
        // This ensures that the broadcaster and prover cannot alter the BETH receiver
        // and cannot claim more BETH than the amount the burner has authorized.
        uint256 burnExtraCommitment =
            uint256(
                    keccak256(
                        abi.encodePacked(_broadcasterFee, _proverFee, _revealedAmountReceiver, _receiverPostMintHook)
                    )
                ) >> 8;

        uint256 poolFee = _revealedAmount / POOL_SHARE_INV; // 0.5%
        uint256 revealedAmountAfterFee = _revealedAmount - poolFee;

        // Information bound to the proof (shifted right by 8 to fit within field elements).
        // The proof generation may be delegated to another party.
        // They can attach their address to the proof so that no one can steal the proverFee
        // by submitting the proof on their behalf.
        uint256 proofExtraCommitment = uint256(keccak256(abi.encodePacked(_prover))) >> 8;

        // Disallow minting more than a MINT_CAP through a single burn.
        require(_revealedAmount <= MINT_CAP, "Mint is capped!");

        // Prover-fee and broadcaster-fee are paid from the revealed-amount!
        require(_proverFee + _broadcasterFee <= revealedAmountAfterFee, "More fee than revealed!");

        // Disallow minting a single burn-address twice.
        require(!nullifiers[_nullifier], "Nullifier already consumed!");
        require(coins[_remainingCoin] == 0, "Coin already minted!");

        bytes32 blockHash = blockhash(_blockNumber);
        require(blockHash != bytes32(0), "Block root unavailable!");

        // Circuit public inputs are passed through a compact keccak hash for gas optimization.
        uint256 commitment =
            uint256(
                    keccak256(
                        abi.encodePacked(
                            blockHash,
                            _nullifier,
                            _remainingCoin,
                            _revealedAmount,
                            burnExtraCommitment,
                            proofExtraCommitment
                        )
                    )
                ) >> 8;
        require(proofOfBurnVerifier.verifyProof(_pA, _pB, _pC, [commitment]), "Invalid proof!");
        if (_broadcasterFee != 0) {
            _mint(msg.sender, _broadcasterFee);
        }
        if (_proverFee != 0) {
            _mint(_prover, _proverFee);
        }
        _mint(_revealedAmountReceiver, revealedAmountAfterFee - _broadcasterFee - _proverFee);

        handleHook(_revealedAmountReceiver, _receiverPostMintHook);
        handleHook(msg.sender, _broadcasterFeePostMintHook);

        mintForRewardPool(poolFee);

        nullifiers[_nullifier] = true;

        coins[_remainingCoin] = _remainingCoin; // The source-coin of a fresh coin is itself
        revealed[_remainingCoin] = _revealedAmount;
    }

    /**
     * @notice Reveals part of an existing BETH "coin" using a zero-knowledge proof.
     * @param _pA zkSNARK proof element A.
     * @param _pB zkSNARK proof element B.
     * @param _pC zkSNARK proof element C.
     * @param _coin The encrypted coin being spent.
     * @param _revealedAmount The amount being revealed/minted to the receiver.
     * @param _remainingCoin The new encrypted coin for the remaining balance.
     * @param _broadcasterFee Fee paid to the transaction sender.
     * @param _receiver The address receiving the revealed amount.
     */
    function spendCoin(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256 _coin,
        uint256 _revealedAmount,
        uint256 _remainingCoin,
        uint256 _broadcasterFee,
        address _receiver
    ) public {
        require(address(rewardPool) != address(0), "Reward pool not initialized!");

        uint256 poolFee = _revealedAmount / POOL_SHARE_INV; // 0.5%
        uint256 revealedAmountAfterFee = _revealedAmount - poolFee;
        require(_broadcasterFee <= revealedAmountAfterFee, "More fee than revealed!");

        uint256 rootCoin = coins[_coin];
        uint256 extraCommitment = uint256(keccak256(abi.encodePacked(_broadcasterFee, _receiver))) >> 8;
        require(rootCoin != 0, "Coin does not exist");
        require(coins[_remainingCoin] == 0, "Remaining coin already exists");
        uint256 commitment =
            uint256(keccak256(abi.encodePacked(_coin, _revealedAmount, _remainingCoin, extraCommitment))) >> 8;
        require(spendVerifier.verifyProof(_pA, _pB, _pC, [commitment]), "Invalid proof!");
        _mint(msg.sender, _broadcasterFee);
        _mint(_receiver, revealedAmountAfterFee - _broadcasterFee);

        mintForRewardPool(poolFee);

        coins[_coin] = 0;
        coins[_remainingCoin] = rootCoin;
        revealed[rootCoin] += _revealedAmount;
        require(revealed[rootCoin] <= MINT_CAP, "Mint is capped!");
    }
}
